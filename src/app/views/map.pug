doctype html
head
  meta(charset='utf-8')
  title Add a 3D model
  meta(name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no')
  link(href='https://api.mapbox.com/mapbox-gl-js/v2.13.0/mapbox-gl.css' rel='stylesheet')
  script(src='https://api.mapbox.com/mapbox-gl-js/v2.13.0/mapbox-gl.js')
  style.
    body { margin: 0; padding: 0; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }
script(src='https://unpkg.com/three@0.126.0/build/three.min.js')
script(src='https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js')
script(src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.1.1/mapbox-gl-directions.js')
link(rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.1.1/mapbox-gl-directions.css" type="text/css")
#map
script(src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js")
script.
  // TO MAKE THE MAP APPEAR YOU MUST
  // ADD YOUR ACCESS TOKEN FROM
  // https://account.mapbox.com
  mapboxgl.accessToken = 'pk.eyJ1IjoiY2FvbWFuaHF1YW5nIiwiYSI6ImNrem45Z3k1dDAzYWwybm53d2VsajYzYnQifQ.6ky4BUk51SfnFaXQdn8uWQ';
  const map = new mapboxgl.Map({
  container: 'map',
  // Choose from Mapbox's core styles, or make your own style with Mapbox Studio
  style: 'mapbox://styles/mapbox/streets-v12',
  zoom: 13,
  center: [-122.414, 37.776],
  pitch: 30,
  antialias: true // create the gl context with MSAA antialiasing, so custom layers are antialiased
  });
  const mapzoom= map.getZoom();
  // parameters to ensure the model is georeferenced correctly on the map
  let modelOrigin = [-122.414, 37.776];
  const modelAltitude = 0;
  function degToRad(deg) {
  return deg * (Math.PI / 180.0);
  }
  function radToDeg(rad){
  return rad/Math.PI*180;
  }
  const modelRotate = [Math.PI / 2, degToRad(0), 0];
  const modelAsMercatorCoordinate = mapboxgl.MercatorCoordinate.fromLngLat(
  modelOrigin,
  modelAltitude
  );
 

  // transformation parameters to position, rotate and scale the 3D model onto the map
  let modelTransform = {
  translateX: modelAsMercatorCoordinate.x,
  translateY: modelAsMercatorCoordinate.y,
  translateZ: modelAsMercatorCoordinate.z,
  rotateX: modelRotate[0],
  rotateY: modelRotate[1],
  rotateZ: modelRotate[2],
  /* Since the 3D model is in real world meters, a scale transform needs to be
  * applied since the CustomLayerInterface expects units in MercatorCoordinates.
  */
  scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits()*100
  };

  function move(lng,lat){
  const start = modelOrigin;
  const end=[lng,lat];
  const anpha= turf.bearing(start,end)
  console.log("anpha",anpha)
  if(anpha>0) modelTransform.rotateY=degToRad(180-anpha);
  else{
  modelTransform.rotateY=degToRad(-(180+anpha));
  }
  console.log("anpha",modelTransform.rotateY)
  const x = mapboxgl.MercatorCoordinate.fromLngLat(
  [lng,lat],
  modelAltitude
  );
  modelTransform.translateX = x.x
  modelTransform.translateY = x.y
  modelOrigin = [lng,lat]
  }
  const THREE = window.THREE;
  // configuration of the custom layer for a 3D model per the CustomLayerInterface
  const customLayer = {
  id: '3d-model',
  type: 'custom',
  layout: {
  visibility: 'none',
  },
  renderingMode: '3d',
  onAdd: function (map, gl) {
  this.camera = new THREE.Camera();
  this.scene = new THREE.Scene();
  // create two three.js lights to illuminate the model
  const directionalLight = new THREE.DirectionalLight(0xffffff);
  directionalLight.position.set(0, -70, 100).normalize();
  this.scene.add(directionalLight);
  const directionalLight2 = new THREE.DirectionalLight(0xffffff);
  directionalLight2.position.set(0, 70, 100).normalize();
  this.scene.add(directionalLight2);
  // use the three.js GLTF loader to add the 3D model to the three.js scene
  const loader = new THREE.GLTFLoader();
  loader.load(
  'models/newtruck.glb',
  (gltf) => {
  this.scene.add(gltf.scene);
  }
  );
  this.map = map;
  // use the Mapbox GL JS map canvas for three.js
  this.renderer = new THREE.WebGLRenderer({
  canvas: map.getCanvas(),
  context: gl,
  antialias: true
  });
  this.renderer.autoClear = false;
  },
  render: function (gl, matrix) {
    console.log(map.getZoom())
  if(map.getZoom()>12){
  const rotationX = new THREE.Matrix4().makeRotationAxis(
  new THREE.Vector3(1, 0, 0),
  modelTransform.rotateX
  );
  const rotationY = new THREE.Matrix4().makeRotationAxis(
  new THREE.Vector3(0, 1, 0),
  modelTransform.rotateY
  );
  const rotationZ = new THREE.Matrix4().makeRotationAxis(
  new THREE.Vector3(0, 0, 1),
  modelTransform.rotateZ
  );
  const m = new THREE.Matrix4().fromArray(matrix);
  const l = new THREE.Matrix4()
  .makeTranslation(
  modelTransform.translateX,
  modelTransform.translateY,
  modelTransform.translateZ
  )
  .scale(
  new THREE.Vector3(
  modelTransform.scale* Math.pow(2,mapzoom-map.getZoom()),
  -modelTransform.scale* Math.pow(2,mapzoom-map.getZoom()),
  modelTransform.scale* Math.pow(2,mapzoom-map.getZoom())
  )
  )
  .multiply(rotationX)
  .multiply(rotationY)
  .multiply(rotationZ);
  console.log(rotationX, rotationY, rotationZ)
  this.camera.projectionMatrix = m.multiply(l);
  this.renderer.resetState();
  this.renderer.render(this.scene, this.camera);
  this.map.triggerRepaint();
  }
  }
  };
  map.on('style.load', () => {
   
  map.addLayer(customLayer);
  });
  map.addControl(
  new MapboxDirections({
  accessToken: mapboxgl.accessToken
  }),
  'top-left'
  );
  